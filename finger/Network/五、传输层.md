 1.传输层功能
>1）传输层协议为运行在不同HOST上的进程提供了一种逻辑通信机制，又称为端到端的逻辑通信机制(基于端口)。
>>发送方：将应用递交的消息分成一个或多个的Segment，并向下传递给网络层
>> 接收方：将接收的Segment组装成消息并向上交给应用层。
>2）复用和分用
>3）提供不可靠的交付服务(UDP)
>>基于尽力而为的网络层
>4） 提供可靠、按序的交付服务(TCP)
>>拥塞控制
>>流量控制
>>连接建立

>端口：
>>端口时传输层服务访问点，标识主机中的应用进程，应用进程将其数据通告端口向下交付给传输层。
	
>>TCP和UDP中的端口字段有16bit，可以表示$2^{16}=65536$个端口
>>熟知端口号：
>>>FTP：21
>>>TELNET：23
>>>SMTP：25
>>>DNS：53
>>>TFTP：69
>>>HTTP：80
>>>SNMP：161

2.复用/分用
>如果某层的一个协议/实体直接为上层的多个协议/实体服务，则需要复用/分用
>>发送端进行多路复用：
>>>从多个Socket(一个Socket对应HOST上的一个端口)接收数据，为每块数据封装上头部信息，生成Segment，交给网络层。

>>接收端进行多路分用：
>>>传输层根据头部信息收到的Segment交给正确的Socket(即不同的进程).网络层的IP数据报包括源IP和目的IP，还包括传输层的Segment，主机收到Segment后传输层协议提取IP地址和端口号信息将Segment导向相应的Socket.

>>>传输层无连接分用
>>>>UDP的Socket用二元组标识(目的IP地址，目的端口号)
>>>>主机收到UDP端口后检查段中的目的端口号，将UDP段导向绑定在该端口的Socket

>>>传输层的面向连接分用
>>>>TCP的Socket用四元组标识(源IP地址，源端口号，目的IP地址，目的端口号)
>>>> 接收端利用所有的四个值将Segment导向正确的Socket

3.UDP协议：
>基于IP协议，提供两个附加访问：复用/分用，对数据的错误检查，<mark style="background: #FF5582A6;">IP层的校验和仅仅是对头部，UDP的校验和包括数据</mark>。
>
>在通信之前无需建立连接，直接发送到网络中，尽力到达(Best effort),UDP数据报可能会丢失并且非按序到达
>
>UDP常用于流媒体应用：容忍丢失、速率敏感
>为什么需要UDP？
			 1）UDP无需建立连接，不会引入建立连接的时延
			 2）不需要维护连接状态
			 3）分组首部开销小，只有8B
			 4）能够满足一些实时应用的需求：能够容忍一定的丢失，但是不允许有较大的时延
			 5）支持一对一、一对多、多对一、多对多的交互通信
>>想要在UDP上实现可靠数据传输需要在应用层实现
		 
>UDP报头格式
>>![[Pasted image 20230525220242.png]]

>UDP校验和计算
>>UDP校验和计算之前需要添加上伪首部然后再使用二进制反码求和
>>![[Pasted image 20230525220511.png]]
>>如果UDP数据报部分的长度不是偶数个字节，则需要填充一个0字节

4.TCP协议
>TCP是基于IP协议实现的可靠数据传输协议，主要解决传输的可靠、有序、无丢失、不重复
>TCP连接是点对点的(一个发送方、一个接收方)
>TCP提供全双工通信：允许通信双方能够随时发送数据，为此双方都有接收缓存以及发送缓存
>TCP是面向连接的：在通信之前需要建立连接，通信过程中需要维护连接，更新连接状态应该就是Socket
>TCP还提供了流量控制和拥塞控制：基于流水线窗口

>TCP报头结构：
>>![[Pasted image 20230525221646.png]]
>>1）源端口号：2B
>>2）目的端口：2B
>>3）序号：4B，对每个应用层数据的每个字节进行   编号,即seq.例如一个报文段的序号为301，数据为100B，则最后一个字节的需要为400B，下一个报文段的第一个数据字号应该从401开始。
>>4）确认号：期望收到对方下一个报文段的第一个数据字节的序号
>>5）首部长度：4bit，4字节为单位
>>6）保留：6bit，一般为0
>>7）六个标志位
>>>URG=1，表示紧急指针字段有效
>>>ACK=1,   表示确认序号字段有效
>>>PSH=1， 尽快将段中数据交付接收应用进程
>>>RST=1， 复位信号，重新建立TCP连接
>>>SYN=1， 表示TCP段是一个建立新连接的请求控制字段
>>>FIN=1， 表示请求释放TCP连接

>>8）接收窗口：16bit，用于流量控制
>>9）校验和：16bit，在计算校验和时，与UDP一样需要先添加TCP伪首部，然后计算，包括TCP伪首部、首部、数据
>>10）紧急指针字段：16bit，URG=1有效，指出紧急数据最后一个字节在数据中的位置
>>11）选项字段的长度：最大段长MSS、时间戳、SACK
>>12）填充字段：取值为0，保证首部长度为4B的倍数

>TCP 连接建立
>>TCP连接建立采用C/S模式，主动发起连接建立的应用进程为客户，被动等待连接建立的应用进程为服务器

>>三次握手过程，服务器处于LISTEN(监听)状态.		 
>>>C --->S,  SYN =1 ,seq =x (随机选择一个序号)，SYN报文段不能携带数据，但是消耗一个序号，此时客户端进入SYN-SENT状态
>>>
>>>C<---S, SYN = 1,ACK = 1, ack = x+1, seq = y (随机选择)，这个报文段同样不能携带数据但小号序号，服务端进入SYN-RECV状态
>>>
>>>C ---->S ACK =1 ,ack = y+1 ,seq = x+1,这个报文段可以携带数据，如果不携带数据则不消耗序号 ，客户端进入ESTABLISHED状态
>>>
>>>服务器的资源是在完成第二次握手时分配的，客户端的资源是在完成第三次握手时分配的。
	 
>TCP连接释放：
>>四次挥手：
>>>C--->S,FIN =1，seq = u，u为前面已经传输过的数据的最后一个字节+1，FIN报文段即使不携带数据也要消耗掉一个序号，客户进程进入FIN-WAIT-1状态，发送FIN的一段不能再发送数据但是另一端可以。
>>>
>>>S--->C 服务器接收到连接释放报文后发出确认，确认号ACK = 1,ack = u+1, seq=v ，v同样是前面已经传输过的数据的最后一个字节加+1，服务器进入CLOSE-WAIT状态.此时从客户端到访问的这个方向的连接已经释放，但是服务端到客户端这个方向的连接依旧存在，TCP处于半关闭状态，服务器依旧能够发送数据.
>>>
>>>S--->C如果服务端没有要想客户端发送的数据就释放连接，FIN = 1 ，seq = w(假设服务端又发送了一些数据),ack = u + 1 ,服务器进入(LAST-ACK)

>>>C----->S,客户机收到连接 释放报文 ，ACK =1 seq = u + 1 ，ack = w + 1,经过时间等待计时器设置的时间2MSL后，客户机进入CLOSED状态.
	
>TCP可靠传输
>>TCP通过一系列机制来实现可靠传输:校验、序号(seq),累计确认(ack),重传机制，TCP使用单一重传计时器。
>>引发重传的两种事件：
>>>1）超时，TCP每发送一个报文就会设置一个计时器，如果超时但还没有收到确认就会重传这个报文段
>>>2）冗余ACK
>>>>TCP规定每当比期望序号打的失序报文段到达时，就发送一个冗余ACK，当发送方接受收到冗余ACK时，就可以认为再这个被确认报文段后的报文段丢失需要重传，这个技术也叫做快速重传.

>>如何设置定时器的超时时间?
>>>首先一定是大于RTT的，过于短会造成不必要的重传，过长则会对段丢失时间反应慢.
>>>测量从段发出到收到ACK的时间，SampleRTT，多次测量得到平均值EstimatedRTT
>>>$EstimatedRTT = (1- \alpha)*EstimatedRTT + \alpha*SampleRTT$
>>>$DevRTT = (1- \beta)*DevRTT +\beta*|SampleRTT-EstimatedRTT|,\beta = 0.25$
>>>定时器超时时间
>>>$TimeoutInterval = EstimatedRTT + 4*DevRTT$

>TCP发送方事件：
>>1）从应用层收到数据:
>>> a）创建Segment
>>> b）序列号是Segment的第一个字节的编号
>>> c）开启计时器
>>> d）设置超时时间

>>2）超时：
>>>重传引起超时的Segment
>>>重启计时器

>>3）收到ACK
>>>如果确认之前未确认的Segment
>>>更新SendBase
>>>如果窗口还有没有被确认的分支重新启动定时器

>TCP接收方事件：
>>1）期望序号的报文段按序到达。 所有在期望序号之前的数据都已 经被确认。
>>>延迟ACK，等待500ms，如果没有下一个报文段则发送ACK

>>2）所期望序号的报文段按序到达。 另一个按序报文段等待发送ACK。
>>>立刻发送一个累计确认ACK

>>3）比期望序号大的报文段乱序到达，检测出数据流中的间隔
>>> 立刻发送重复的ACK，指名下一个期待字节的序号

>>4）能够部分或完全填充接收数据的间隔的报文段到达。
>>>如果报文端位于间隔的低端则立即发送ACK

>TCP流量控制
>>消除发送方(发送速率太快)使得接受方缓存区溢出
>>接收方根据自己接收缓存的大小，动态的调整发送方的发送窗口的大小，这成为接收窗口(rwnd)
>>发送方更具对当前网络拥塞程度的故居而确定窗口值称为拥塞窗口(cwnd)

>TCP拥塞控制
>>LastByteSent-LastByteAcked<= CongWin
>>(CongWin为拥塞窗口，窗口数量为最大报文段MSS的个数)
>>如何感知拥塞？
>>>Loss事件=timeout或3个重复ACK
>>>发生Loss事件后，发送方降低速率

>>加性增乘性减AIMD
>>> 逐渐增加发送速率，谨慎探测可用带宽，知道发生丢失事件
>>> AI(Additive Increase)：每个RTT将CongWin增大一个MSS(拥塞避免阶段)
>>> MD(Multiplicative Decrease):发生丢失事件后将CongWin减半
>>慢启动(Slow Start)
>>>TCP建立时，CongWin = 1(WSS),每收到一个对报文段的确认后将CongWin加1，这样CongWin就呈指数型增长(每一个RTT,CongWin大小翻倍).

>>拥塞避免：
>>>为SS设置一个阈值变量Threshold,当CongWin大于Threshold后进入线性增长阶段,每一个RTT,CongWin+1
>>>
>>>CongWin < Threshold ，使用SS算法，指数增长.
>>>CongWin > Threshold ,   使用拥塞避免算法,线性增长.
>>>CongWin > Threshold，二者都行，通常使用拥塞避免算法.

>>丢失事件的处理:
>>>	1）收到3个重复ACK，Threshold设置为CongWin/2,拥塞窗口CongWin设置为Threshold/2.
>>>	2）发生超时，Threshold设置为CongWin/2,拥塞窗口CongWin设置为1.

>>TCP的吞吐率
>>>给定拥塞窗口大小和RTT，求TCP的平均吞吐率
>>>假设发生超时时CongWin的大小为W，吞吐率为W/RTT
>>>超时后，CongWin = W/2，吞吐率为W/2RTT
>>>平均吞吐率为0.75W/RTT
>>>throughput = $W*MSS*8/RTT$
>>>则$W=throughput*RTT/(MSS*8)$
>>吞吐率与丢包率的关系:
>>>CongWin从W/2到W时出现第一个丢包，一共发送的分组为
>>>$(W/2)+(W/2+1)+(W/2+2)+\dots+W=2W^{2}/8+4W/4$
>>>W很大时,$L=8/(3W^{2})$,$W=\sqrt{8/3L}$
>>>$Throughput=0.75*MSS*W/RTT = 1.22MSS/(RTT\sqrt{L})$
>>TCP的公平性
>>>如果K个TCP Session共享相同的瓶颈带宽R，那么每个Session的平均速率为R/K
				 ![[Pasted image 20230528112301.png]]
				 
				 