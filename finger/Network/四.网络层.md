1.网络层的功能：
>异构网络互连：网络层的中继系统为路由器
>路由与转发
>>1）路由选择：按照复杂的分布式算法（路由协议），根据从各相邻路由器所得到的关于整个网络拓扑的变化情况，动态的改变所选择的路由。
>>2）分组转发：路由器根据转发表将用户的ip数据报从合适的端口转发出去。

>连接建立
>>数据分组传输之前两端主机需要首先建立虚拟/逻辑连接，网络设备参与连接的建立。
>>网络层的连接是两个主机之间的连接，传输层的连接是两个应用进程(端口)之间的连接。

>拥塞控制：
>>拥塞：因出现过量的分组而引起网络性能下降的现象成为拥塞。表现为分组丢失和分组延迟过大(在路由器缓存中排队)

 2.虚电路网络与数据报网络
>虚电路网络与数据报网络是分组交换的两种方式，数据报网络提供无连接服务，虚电路网络提供连接服务。
>1）虚电路服务：在发送分组前，在发送方和接收方之间建立一条逻辑上相连的虚电路，每个分组利用链路的全部带宽
>>通信过程：使用虚电路信令协议
>>>a）建立虚电路。主机A发出一个特殊的“呼叫请求“分组，该分组通过中间结点发送给主机B，如果B同意连接，则发送一个”呼叫应答“分组予以确认。
>>>b）虚电路建立后，A与B可以互相发送数据分组
>>>d）传送结束后，A通过发送”释放请求“分组拆除虚电路，逐渐断开整个连接

>>注：
>>> a）虚电路通信链路的建立与拆除需要时间开销，对交互式应用和小量的短分组情况显得很浪费，但对长时间、频繁的数据交换效率高。
>>> b）虚电路的路由选择体现在连接建立阶段，连接建立后确定传输路径
>>> c）虚电路提供了可靠的通信功能，保证每个分组正确切有序到达。还能够对两个数据断点进行流量控制
>>> d）如果网络中的某个结点或者链路出现问题，那么经过它们的虚电路都会失效。
>>> e）虚电路建立后，分组首部不包含目的而是包含虚电路标识符VCID

>2）数据报网络
>>无连接服务，端系统发送一个报文时，先将报文拆成带有序号的数据单元，在网络层加上地址等控制信息形成数据报分组(PDU)。
>>路由器根据分组的目的地址转发分组，根据路由协议/算法构建转发表，检索转发表，每个分组独选链路。
>>最长前缀匹配优先：在检索转发表时，优先选择与分组目的地址相匹配前缀最长的入口.		

 3.IP协议
>IP报头格式：
>> ![[Pasted image 20230523142857.png]]

>> 1）版本号：4bit, ipv4或则ipv6

>> 2）首部长度：4bit，以4字节为单位，一般等于5

>> 3）服务类型：8bit，表示期望获取哪种类型的服务，一般为00H

>> 4）总长度：16bit，表示首部加上数据的长度，单位为1字节，因此数据包最大长度为$2^{16}-1=65535$
>> 由于以太网的最大传输单元MTU=1500B，所以IP数据报封装成帧时不能超过MTU。

>> 5）标识：16bit，一个计数器，每产生一个数据报就加1，对于一个数据报大小超过MTU，需要分片，每个分片都复制这个标识。

>> 6）标志位：3bit，分别是X_DF_MF，X表示未使用，MF=1表示后面还有分片，MF=0表示最后一个分片；DF=0时表示允许分片

>> 7）片偏移：13bit，当数据报分片后，某片在原分组中的相对位置，以8B位偏移单位。

>> 8）TTL：8bit，分组可以通过的路由器数的最大值，路由器在转发分组时将TTL减一，如果TTL=0，则丢弃分组。

>> 9）协议：8bit，上层协议，6=TCP，17=UDP

>> 10）首部校验和：16bit，实现对IP分组首部的差错检测，计算校验和时，将该字段赋为0，然后采用反码运算求和，最后取反作为校验和。
>> 逐跳计算，逐跳校验：每次路由及转发后都要重新计算。

>> 11）源IP地址：4B

>> 12）目的ip地址：4B

>> 13）选项字段：携带安全、源选路径、时间戳、路由记录等内容，很少使用。

>> 14）填充：保证首部位4B的倍数

>IP分片：
>>MTU：网络链路存在MTU(最大传输单元)，表示链路层数据帧可以封装数据的上限，不同链路的MTU不同，以太网为1500B，广域网为576B。
>>
>>当IP数据分组大于MTU时，需要对其进行分片，利用总长度、标识、标志位和片偏移来标识分片以及确定分片的相对顺序。
			 
>>分片过程：
>>>假设源IP分组总长度位L，MTU = M，DF=0 允许/需要分片
>>>
>>>首先确定一个最大分片可以封装的数据：$d=\lfloor(M-20)/8\rfloor*8$
>>>然后确定需要的总片数： $n=\lceil(L-20)/d\rceil$
>>>
>>>每片的片偏移字段为：$F_i=\frac{d}{8}*\left( i-1 \right) ,\ 1\le i\le n$			 

>>>每片的总长度字段为：
>>>>$L_{i} = d+20, if\ \ 1 \leq i<n$
>>>>$L_{i} = L-(n-1)d, if\ \  i=n$

>>>每片的MF标志位为：
>>>>$MF_{i} = 1, if\ \ 1 \leq i<n$
>>>>$MF_{i} = 0 if\ \  i=n$

>IP编址：
>>IPV4地址：32bit编号标识主机、路由器的接口，由ICANN进行分配
>>IP地址={<网络号(Net ID)>，<主机号(Host ID)>}
>>
>>IP子网:
>>>IP地址具有相同的网络号的设备接口
>>>不跨越路由器(第三及以上层网络设备)，可以彼此物理联通的接口.
>>>>有类编址：
>>>>>![[Pasted image 20230523153820.png]] 

>>>>特殊地址：
>>>>>![[Pasted image 20230523154005.png]]
				
>>>私有地址网段：
>>>>A类：10.0.0.0 到 10.255.255.255
>>>>B类：172.16.0.0 到 172.31.255.255
>>>>C类：192.168.0.0 到 192.168.255.255
				
>>>子网划分：
>>>>{<网络号(Net ID)>，<子网号(SubID)>，<主机号(Host ID)>}
>>>>任何确定是否划分的子网？利用多少位划分子网？-> 利用子网掩码实现
>>>>取值：
>>>>>NetID，SubID全取1
>>>>>HOSTID 取0
>>>>>A网的默认子网掩码为：255.0.0.0
>>>>>B网的默认子网掩码为：255.255.0.0
>>>>>C网的默认子网掩码为：255.255.255.0
>>>>>借用3bit划分子网的B网的子网掩码为：255.255.224.0
>>>>>将IP分组的目的IP地址与子网掩码按位与运算，得到子网地址。

>>>无类域间路由CIDR(Classless InterDomain Routing)
>>>>消除传统的A类、B类、C类地址界限
>>>>融合子网地址与子网掩码，方便子网划分
>>>>无类地址格式a.b.c.d/x,其中x为前缀长度
>>>>比如 201.2.3.64，255.255.255.192  ——> 201.2.3.64/26
>>>>提高了IPV4地址空间分配效率
>>>>提高路由效率
>>>>>a）将多个子网聚合为一个较大的子网
>>>>>b）构造超网
>>>>>c）路由聚合

>IPV6
>>动机
>>1）32位IPV4地址空间已经分配殆尽
>> 2）改进首部格式：
>>快速处理/转发数据报
>>支持QoS

>>数据报格式：
>>> ![[Pasted image 20230523161724.png]]

>>>![[Pasted image 20230523161740.png]]

>>相较于IPV4，移除了校验和，减少了每跳的处理时间，ICMPV6：新版ICMP

>>地址表现形式：
>>>一般形式：1080:0:FF:0:8:800:200C:417A，一共由32个16进制数，共八组，每组4个

>>IPV4如何向IPV6过渡？
>>>使用隧道(tunneling):IPV6数据报作为IPV4数据报的载荷进行封装穿越IPv4网络.

4.IP相关协议：
>ARP：地址解析协议
>>LAN中的每个IP结点(主机、路由器)维护一个表
>> 存储某些结点的IP/MAC地址映射关系，以及TTL(Time To Live)：生存时间，经过这个时间后这个entry会被丢弃，典型的值位20min
>><IP地址，MAC地址；TTL>

>>寻址过程：
>>>1）主机A与主机B在同一个局域网内
>>>> a）A想要给B发送数据报，并且此时B的MAC地址不在A的ARP表中
>>>> b）A广播ARP查询地址，其中包含B的IP，Where is ip of B
>>>> c）B接收到ARP查询分组，IP地址匹配成功，向A应答B的MAC地址，利用单播帧向A发送应答，
>>>> d）A在其ARP表中缓存B的IP-MAC地址，直至超时(超时后再次刷新)
			 
>>>2）主机A和主机B在不同的LAN中
>>>>通过中间路由器转发		

>>ARP数据格式：
>>>![[Pasted image 20230524113204.png]]	 
>互联网控制报文协议(ICMP)
>>支持主机或者路由器：
>>>差错(或者异常)报告
>>>网络探询

>>两类ICMP报文：
>>>差错报告报文:
>>>>目的不可达
>>>>源抑制
>>>>超时/超期
>>>>参数问题
>>>>重定向
>>>网络探询
>>>>回声请求与应答报文,比如：ping指令
>>>>时间戳请求与应答报文

>>报文格式
>>>![[Pasted image 20230523163424.png]]
>>>差错报文数据封装
>>>![[Pasted image 20230523163446.png]]
	
>动态主机配置协议DHCP(Dynamic Host Configuration Protocol)	 
>>一个主机如何获取IP地址?
>>>“硬编码” : 静态配置
>>>
>>>从服务器动态获取：
>>>>IP地址
>>>>子网掩码
>>>>默认网关地址
>>>>DNS服务器名称与IP地址

>>>通信过程：
>>>>a）主机广播“DHCP discover”(发现报文)
>>>>b）DHCP服务器利用“DHCP offer”(提供请求)进行响应
>>>>c）主机请求IP地址：“DHCP request”(请求报文)
>>>>d）DHCP服务器分配IP地址:"DHCP ack"(确认报文) ，DHCP服务器构造的ACK报文包括分配给客户的IP地址、子网掩码、默认网关、DNS服务器地址
		 
>>DHCP协议在应用层实现
>>>DHCP报文封装到UDP数据报中
>>>IP广播
>>>链路层广播

>网络地址转换NAT
>>动机：
>>>1）只需/能从ISP申请一个IP地址：ipv4地址耗尽
>>>2）本地网络设备IP地址的变更，无需通告外界网络
>>>3）变更ISP时，无需修改内部网络设备IP地址
>>>4）内部网络设备对外界网络不可见，即不可直接寻址(安全)

>>所有离开本地网络去往Internet的数据报的源IP地址需替换为相同的NAT IP地址以及不同的端口号。
>>本地网络内通信的IP数据报的源于目的IP地址均在子网10.0.0/24内
>>实现：
>>>1）替换
>>>>利用(NAT IP地址，新端口号)替换每个外出IP数据报的(源IP地址，源端口号)

>>>2）记录
>>>>将每对(NAT IP地址，新端口号)与(源IP地址，源端口号)的替换信息存储到NAT转换表中

>>>3）替换
>>>>根据NAT转换表，利用(源IP地址，源端口号)替换每个进入内网ip数据报的(目的IP地址，目的端口号)，即(NAT IP地址，新端口号)
>>>>端口号字段为16bit，可以支持$2^{16}=65536$个并行连接.

>>NAT主要帧：
>>
>>路由器应该只处理第三层功能
>>
>>违背端到端通信原则
>>
>>应用开发者必须考虑到NAT的存在
>>
>>地址短缺问题应该由IPv6来解决
>>
>>NAT穿透问题
>>>客户期望连接内网地址为10.0.0.1的服务器，客户不能直接利用10.0.0.1直接访问服务器，对外唯一可见的地址是NAT地址:138.76.29.7.
>>>
>>>解决方法
>>>>1）静态配置NAT
>>>>>将特定端口的连接请求转发给服务器,(138.76.29.7,2500)总是转发给(10.0.0.1,25000)
>>>>
>>>>2）利用UPnP协议自动配置
>>>>>学习到NAT公共IP地址
>>>>>在NAT转换表中增删端口映射.
 
>>>>3）中继
>>>>>NAT内部的客户于中继服务器建立连接.
>>>>>外部客户也与中继服务器建立连接
>>>>>中继服务器桥接两个连接的分组

 6.路由算法	 
>将网络中结点和链路抽象为图		
>>图中边的长度为链路的费用，费用可以是或至少宽带的倒数，拥塞程度等
	
>关键问题：找到源到目的的最小费用路径

>路由算法：寻找最小费用路径的算法
>>路由算法分类:
>>>1）全局信息：
>>>>所有路由器掌握完整的网络拓扑和链路费用信息。
>>>>链路状态(LS)路由算法

>>>2）分散信息:
>>>>路由器只掌握物理相连的邻居以及链路费用。
>>>> 邻居间信息交换、运算的迭代过程
>>>> 距离向量(DV)路由算法

>>> 静态路由：
>>>>手工配置
>>>>路由更新慢
>>>>优先级高

>>>动态路由：
>>>>路由更新快
>>>>定期更新快
>>>>及时响应链路费用或网络拓扑变化

>>链路状态路由算法:
>>>DijKstra算法:
>>>>计算从一个结点("源")到所有其他结点的最短路径:获得该结点的转发表
>>>>迭代:k次迭代后，得到到达K个目的结点的最短路径
>>>>符号定义:
>>>> c(x,y):x到y的链路费用，如果x与y不直接相连则=∞
>>>> D(v):从源结点到v的当前路径的费用
>>>> p(v):沿源到v的当前路径，v的前序结点
>>>> $N^{’}$:已经找到最小费用路径的结点集合

>>>算法流程:
>>>>![[Pasted image 20230524135117.png]]
>>>>```c
>>>>int dij(int node1, int node2,int n, vector<vector<int>>& edges){
>>>> int visited[n];
>>>> int graph[n][n];
>>>> int min_d[n];
>>>> int cnt = n;
>>>> //初始化图为矩阵形式
>>>> for(int i = 0; i < n; i++){
>>>>     visited[i]=0;
>>>>     min_d[i] = 10000000;
>>>>     for(int j = 0; j < n; j++){
>>>>        graph[i][j] = 10000000;
>>>>     }
>>>> }
>>>> for(int i = 0; i < edges.size(); i++){
>>>>     graph[edges[i][0]][edges[i][1]]=edges[i][2];
>>>> }
>>>> visited[node1] = 1;
>>>> cnt--;
>>>> min_d[node1] = 0;
>>>> for(int i = 0; i < n; i++){
>>>>     if(i!= node1){
>>>>         min_d[i] = graph[node1][i];
>>>>     }    
>>>> }
>>>> while(cnt){
>>>>     int index=0;
>>>>     int min_dst=10000000;
>>>>     for(int i = 0; i < n; i++){
>>>>         if(!visited[i]&&i!=node1&&min_dst>min_d[i]){
>>>>             min_dst = min_d[i];
>>>>             index = i;
>>>>         }
>>>>     }
>>>>     visited[index] =1;
>>>>     for(int i = 0; i < n; i++){
>>>>         if(i!=node1&&graph[index][i]!=10000000){
>>>>             min_d[i] = min(min_d[i],min_d[index]+graph[index][i]);
>>>>         }
>>>>     }
>>>>     cnt--;
>>>> }
>>>> if(min_d[node2]==10000000) return -1;
>>>> return min_d[node2];
    }
>>>>```

>>>
>>>算法复杂性：
>>>>每次迭代：需要检测所有不再集合$N^{’}$中的结点W
>>>>$n(n+1)/2$次比较:O($n^{2}$)
>>>>更高效的实现:O(nlogn)
>>>>存在震荡的可能:

>>距离向量路由算法:
>>>Bellman-Ford方程(动态规划)
>>> $d_{x}(y):=$从x到y最短路径的费用(距离)
>>> 则$d_{x}(y)=\min\limits_{v}\{c(x,v)+d_{v}y\}$
>>> 其中c(x,v)是x到期邻居v的费用
>>> x维护距离向量(DV):$D_{x}=[D_{X}(y):y∈N]$
>>> 
>>>核心思想:
>>>>每个结点不定时的将其自身的DV估计发送给其邻居
>>>>当x接收到邻居的新的DV估计时，依据B-F更新其自身的距离向量估计:
>>>> $D_{x}(y)=\min\limits_{v}\{c(x,v)+D_{v}y\},for\ each\ node\ y∈N$
>>>> $D_x{t}$最终将收敛能到实际的最小费用

>>>异步迭代:
>>>>引发每次局部迭代的因素:
>>>> 局部链路费用的改变
>>>> 来自邻居的DV更新

>>>分布式：
>>>>每个结点只当DV变化时菜通告给邻居

>>>对每个结点:
>>>>a）等待(本地链路费用的改变，或来自邻居的DV更新)
>>>>b）重新计算DV估计
>>>>c）如果DV中到达任一目的距离发生该边通告所有邻居，回到步骤a.

>>>无穷计数问题：
>>>>![[Pasted image 20230524172439.png]]
				 
>>>>对于以上的网络拓扑图，当x到y的链路从4变成了60
>>>>由于y维护了z的距离向量，得知从z到x的费用为5,因此它更新自己的距离向量$d_{y}(x)=6$，并且告知z,
>>>>然后z同样更新到x距离$d_{z}(x)=7$,并且告知y...
>>>>
>>>>因此结点y与结点z到x的距离会不断的增加.
>>>>引发这个问题的原因是，z到x的最短路径是经过y的，但是y不知道这一点。
>>>>解决方法:
>>>>>毒性逆转:
>>>>>> 如果一个结点(比如上图的Z)到达某个目的(X)的最小费用路径经过某个邻居(Y)则：通告给该邻居Y到达目的结点的距离为无穷大.

>>>>>定义最大度量(maximum metric):
>>>>>>定义一个最大的有效费用值，比如15跳步为最大的有效条数，16跳步表示无穷大

>>LS与DV算法比较：
>>>1）报文交换复杂性：
>>>>LS：对于n个结点，E条链路的网络,发送报文为O(nE)级
>>>>Dv：只在邻居之间交换DV

>>>2）收敛速度：
>>>>LS:时间复杂度O($n^{2}$)，信息复杂度为O(nE)
>>>>可能产生震荡
>>>>DV：收敛时间不定
>>>>可能出现路由环路
>>>>无穷计数

>>> 3）健壮性：如果路由器发生了故障
>>>> LS：结点可以通告失效链路代价
>>>>	 每个几点计算自己的转发表
>>>> DV：结点通告DV通告错误路径代价
>>>>每个几点基于邻居结点的转发表计算自己的转发表

 7.层次路由
>动机：
>>将任意规模网络抽象为一个图计算路由过于理想化
>>考虑数亿计结点的网络：路由表无法储存，路由计算过程的信息交换量巨大，会淹没链路。
>>
>>管理自治：
>>>每个网路的管理可能都期望自主控制其网内的路由
>>>互联网 =  网络之网络
>>>聚合路由器为一个区域：自治系统AS(autonomous systems)
>>>
>>>同一AS内的路由器运行相同的路由协议(协议)
>>>
>>>自治系统内部路由协议("intra-AS"路由协议)
>>>
>>>不同自治系统内的路由器可以运行不同的AS内部路由协议
>>>
>>>网关路由器位于AS边缘，通过链路连接其他AS的网关路由
>>>转发表由AS内部路由算法与AS间路由算法共同配置
>>>
>>>AS内部路由算法设置AS内部目的网络路由入口
>>>AS内部路由算法与AS间路由算法共同设置AS外部目的网络路由入口。

 8.路由协议：
>AS内部路由协议也称为内部网关协议IGP
>路由信息协议RIP(Router Information Protocol)
>>采用距离向量路由算法：
>>>距离度量：跳步数(max = 15 hops)，每条链路一个跳步
>>>每隔30秒，邻居之间交换一次DV，称为通告
>>>每次通告：最多25个目的子网
>>>如果180秒没有收到通告则表示邻居/链路失效：
>>>这个时候需要重新计算路由并向邻居发送新的通告，邻居再次向外发送通告
>
>>RIP路由表是用一个称为route-d(daemon)的应用层进程进行管理
>>>应用进程实现
>>>通告报文周期性的通过UDP数据报发送

>OSPF(Open Shortest Path First)
>>开放:公共可用
>>采用链路状态路由算法:
>>>LS分组扩散(通告)
>>>每个路由器构造完整的网络拓扑图
>>>利用Dijkstra算法
			 
>>OSPF通告中每个入口对应一个邻居
>>OSPF通告在整个AS范围泛洪
>>OSPF报文直接封装到IP数据报中
>>优点：
>>>1）安全：所有OSPF报文可以被认证(预防恶意入侵)
>>>2）运行使用多条相同费用的路径(RIP只能选一条)
>>>3）针对每条链路可以针对不同的TOS设置多个不同的费用度量
>>>4）集成单播路由与多播路由
>>>5）OSPF支持对大规模AS分层

>>两分级层：局部区和主干区
>>>区边界路由器:“汇总”到达所在区网络的距离通告给其他区边界路由器。
>>>主干路由器：在主干区内运行OSPF路由算法
>>>AS边界路由器：
>>>>连接其他AS

>BGP(Border Gateway protocol):
>>事实上的标准域间路由协议:将Internet “粘合”为一个整体的关键
>>为每个AS提供了一种手段:
>>>eBGP：从邻居AS获取子网可达性
>>>iBGP：向所有AS内部路由器传播子网可达性
>>>基于可达性信息域策略，确定到达其他网络的“好”路径

>>BGP基础：
>>>BGP会话：两个BGP路由器("Peers")交换BGP报文
>>>>通告去往不同目的前缀的路径
>>>>基于TCP连接

>>>BGP报文：
>>>>OPEN：与peer建立TCP连接，并认证发送方
>>>>UPDATE：通告新路径(或撤销源路径)
>>>>KEEPALIVE：无UPDATE时，保活连接，也用于对OPEN请求的确认
>>>>NOTIFICATION：报告之前报文的差错；也用于关闭连接			 
			 
						
	