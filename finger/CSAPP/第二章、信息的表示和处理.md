 信息的位表示:
	 位、字节、字：
		 位：bit
		 字节：8-bit块
		 字：CPU中ALU的数据位数=CPU中通用寄存器的位数
	 二进制数：逢二进一，由0和1两个数码组成，基数为2，各个位权以$2^{i}$表示
	 MSB:最高有效位(Most Signficant Bit)
	 LSB：最低有效位(Least Signficant Bit)
	 进制转换：十进制整数转换位k进制数
		 除法-除基取余法：
			 十进制数整数部分不断除以基数k，并且记下余数，直到商位0为止.
			 由最后一个余数起，逆向取各个余数，则转换成二进制和十六进制数.
	     3个2进制位对应1个8进制位
	     4个2进制位对应1个16进制位
 编码：
	 ![[Pasted image 20230609155101.png]]
 位运算：
	 布尔代数：
		 与、或、非、异或
	 C语言中的移位运算(无循环移位)
		 左移：$x<<y$
					将位向量x向左移动y位：扔掉左边多出的位，右边补0
		 右移：$x>>y$
					 将位向量x向右移动y位
					 扔掉右边多出的位
					 对于左边：
						 逻辑右移：左边补0
						 算数右移：补充符号位
 整形数：
	 表示：
		 无符号数：$B2U(X)=\sum_{i=0}^{w-1}x_{i}\cdot2^{i}$
		 有符号数：补码形式$B2U(X)=-x_{w-1}\cdot2^{w-1}+\sum_{i=0}^{w-2}x_{i}\cdot2^{i}$
	 表示范围：
		 无符号数值,n位：$0-2^{w-1}$
		 补码数值:$-2^{w-1}-2^{w-1}-1$
	 ![[Pasted image 20230609162743.png]]
	![[Pasted image 20230609162846.png]]
	 扩展：
		 无符号数，填充0
		 有符号数，符号位扩展
		 结果都是明确的预期值
	 阶段：
		 无论有/无符号数：多出的位均被截断
		 结果重新解读
		 无符号数：相当于求模运算
		 有符号数：与无符号数类似，需要将余数按照补码重新解读.
     整数运算：
	     无符号数加法：
		     操作数：w位
		     真实和：w+1位
		     丢弃进位：w位
		     $s=UAdd_{w}(x,y)=(x+y)mod2^{w}$
		 补码加法：
			 真实和需要w+1位
			 丢弃最高的有效位
			 将剩余的位视为补码(整数)$$
TAdd\left( x,y \right) =\left\{ \begin{array}{l}
	x+y-2^w,\ \ TMax_w<x+y\ \text{正溢出}\\
	x+y,\ \ \ TMin_w\le x+y\le TMax_w\ \text{正常}\\
	x+y+2^w,\ \ x+y<TMin_w\ \text{负溢出}\\
\end{array} \right. 
$$
			 $Xh!=Yh$或者$Xh==Yh==Zh$则正常(Z=X+Y)
			 $Xh==Yh!=Zh$则溢出	
		 乘法：w位整数x、y的乘积，
			 乘积的无符号数最多可以达到2w位
				 $0\leq x*y\leq(2^{w}-1)^{2}=2^{2w}-2^{w+1}+1$
			 补码的最小值(负数)最多需要2w-1位:
				 $x*y\geq(-2^P{w-1})*(2^{w-1}-1)=-2^{2w-2}+2^{w-1}$
			 补码的最大值最多需要2w位
				  $x*y\leq(-2^{w-1})^{2}=2^{2w-2}$
 字节序：
 ![[Pasted image 20231123213234.png]]
	 大端序、大尾序：最低有效位字节的地址最高
	 小端序、小尾序：最低有效位字节的地址最低
 浮点数：
		 IEEE754标准
			 ![[Pasted image 20230609173157.png]]
			 ![[Pasted image 20230609173340.png]]
			 
	 
				 
				 
				 	 
		 
		 
		 